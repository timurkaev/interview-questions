## 1. Что такое `React`?
* React - это JavaScript библиотека с открытым исходным кодом разработанная компанией facebook,
  предназначен для создания пользовательских интерфейсов.

* React представляет слой представления, то-есть в мобильных и веб приложениях.
* Основная философия это компонентный подход(то-есть весь интерфейс может быть разбит на минимальные функционирующие единицы)

## 2. Перечислите особенности `React`.
* Использование  `Virtual DOM`. Делается это потому-что манипуляция c реальным DOM деревом тяжеловесна, а `Virtual DOM` 
это по сути объект, на основании которого строится реальный DOM, поэтому все операции перерисовки происходят намного быстрее.
   
* Поддержка рендеринга на стороне сервера(`SSR`). Используя React, вся разметка используется внутри одного корневого элемента `div`,
что не очень хорошо для SEO, в связи с чем в React была добавлена поддержка SSR, в этом случае первоначальная разметка строится на сервере
и полностью передается и отрисовывается на клиенте

* React придерживается принципа однонаправленного потока данных(`One way direction data flow`), 
то-есть все данные передаются от корневых компонентов во вложенные


4. Использование переиспользуемых компонентов(`Reusable components`) для построения пользовательского интерфейса

## 3. Что такое `Virtual DOM` и как он работает с React?

Главная проблема `DOM`, что он никогда не был рассчитан для создания пользовательского динамического интерфейса.

DOM представляет собой древовидную структуру данных. Поэтому изменения и обновления самого `DOM` являются достаточно быстрыми. 
Но после изменения обновленный элемент и все его потомки (дочерние элементы) 
должны быть повторно отрисованы(отрендерены) для обновления UI приложения.
Повторный рендеринг — очень медленный процесс. Таким образом, чем больше у нас компонентов UI, 
тем более дорогими с точки зрения производительности являются обновления `DOM`.


Допустим, у нас имеется список из 10 элементов. Мы изменяем первый элемент. Большинство фреймворков перестроят весь список. 
Это в 10 раз больше работы, чем требуется! Только 1 элемент изменился, остальные 9 остались прежними.


***Почему Virtual DOM является более быстрым?*** Когда в UI добавляются новые элементы, создается `Virtual DOM` в виде дерева. 
Каждый элемент является узлом этого дерева. При изменении состояния любого элемента, создается новое дерево. 
Затем это новое дерево сравнивается (diffed) со старым.

После этого вычисляется наиболее эффективный метод внесения изменений в реальный `DOM`. 
Цель данных вычислений состоит в минимизации количества операций, совершаемых с реальным `DOM`. 
Тем самым, уменьшаются накладные расходы, связанные с обновлением реального `DOM`.

![](https://habrastorage.org/r/w780/getpro/habr/post_images/a24/a2a/a11/a24a2aa1136f517abc80ae25c20f6c8a.png)


Красным цветом обозначены узлы, которые были обновлены. Эти узлы представляют элементы UI, состояние которых изменилось. 
После этого вычисляется разница между предыдущей и текущей версиями виртуального `DOM-дерева`. 
Затем все родительское поддерево подвергается повторному рендерингу для представления обновленного UI. 
Наконец, это обновленное дерево используется для обновления `RDOM`.


![](https://habrastorage.org/r/w780/getpro/habr/post_images/12a/500/0c2/12a5000c239d0c3eb96cd4848e7221a1.jpg)


## 4. Что такое `JSX`?
`JSX(JavaScript XML)` - это новый диалект языка javascript, который внедряет необработанный HTML шаблон внутрь кода javascript.
ReactJS использует этот формат для того, чтобы сделать код HTML более простым для чтения и записи


## 4. Для чего нужен атрибут `key` при рендере списков?
`Ключи(key)` помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, 
чтобы React мог сопоставлять элементы массива с течением времени.


## 5. Что такое `PureComponents`?

`PureComponent` изменяет `lifecycle-метод` `shouldComponentUpdate`, автоматически проверяя, нужно ли заново отрисовывать компонент. 
При этом `PureComponent` будет вызывать рендер только если обнаружит изменения в `state` или props компонента, 
а значит во многих компонентах можно менять `state` без необходимости постоянно писать.


Чтобы использовать `PureComponent`, замените:
```jsx
class MyComponent extends Component {}
```
на:
```jsx
class MyComponent extends PureComponent {}
```

`PureComponent` выполняет “неглубокую” проверку в `shouldComponentUpdate` (это уже реализовано “из коробки”), и, 
если данные были изменены, то только тогда срабатывает обновление.

Разница между `Component` и `PureComponent` заключается в методе updating lifecycle: `shouldComponentUpdate`.

В `Component` этот метод выглядит так:
```jsx
shouldComponentUpdate() {
 return true;
}
```
В `PureComponent`:
```jsx
shouldComponentUpdate(nextProps, nextState) {
 return !shallowEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);
}
```
`PureComponent` изначально определяет функцию, которая ответственна за принятие решения — нужно ли продолжать updating`lifecycle` или нет.

В react `lifecycle` компонентов существуют два процесса: `mounting` и `updating`.
Mounting `lifecycle` выглядит так:
1) `constructor`
2) `componentWillMount — deprecated`
3) `render`
4) `componentDidMount`
   

   Updating `lifecycle`:
1) `componentWillReceiveProps`
2) `shouldComponentUpdate`
3) `componentWillUpdate — deprecated`
4) `render`
5) `componentDidUpdate`

## 6. Что такое Компонент высшего порядка `(Higher-Order Component / HOC)`?
`HOC` — это особая техника в React, при которой функция принимает аргумент Component и возвращает новый компонент.
То-есть это продвинутая техника переиспользования компонентной логики. Это не часть API а паттерн

```jsx
import React from 'react'

const higherOrderComponent = WrappedComponent => {
  class HOC extends React.Component {
    render() {
      return <WrappedComponent />
    }
  }
  return HOC
}
const SimpleHOC = higherOrderComponent(MyComponent); // Вызываем наш HOC компонент

```
В приведенном выше примере `higherOrderComponent` — это функция, которая принимает компонент с именем 
`WrappedComponent` в качестве аргумента. Мы создали новый компонент под названием `HOC`, который возвращает 
`<WrappedComponent/>` из функции рендеринга. Хотя это на самом деле не добавляет функциональности, 
оно изображает общий шаблон, которому будет следовать каждая функция `HOC`.


## 7. Разница между управляемыми `controlled` и не управляемыми `uncontrolled` компонентами?
В HTML такие элементы как `<input />`, `<select>`, `<textarea>` обычно сами управляют своим состоянием и обновляют его
когда пользователь вводит данные. В react изменяемое состояние обычно содержится в свойстве компонента `state`, 
и обновляется через вызов `setState`, либо при использовании хука `useState`.

Неуправляемые компоненты опираются на DOM в качестве источника данных, то-есть обычные HTML элементы которые обновляются динамически

В управляемом компоненте с каждым изменением состояния связана функция обработчик, а сами обновляемые данные хранятся
внутри свойства компонента `state`, благодаря этому механизму, данные хранятся внутри управляемых элементов, и могут
быть доступны за их пределами, и с ними можно легко взаимодействовать.

```jsx
// Неконтролируемый компонент

const UncontrolledComponent = () => {
  return (
      <div>
        <label>Uncontrolled component</label>
        <input type='text' value="value"/>
      </div>
  );
};


// Контролируемый компонент

const ControlledComponent = () => {
  const [value, setValue] = useState('');
  
  const changeValue = (event) => {
    setValue(event.target.value);
  };
  
  return (
      <div>
        <label>Controlled component</label>
        <input type='text' value={value} onChange={changeValue} />
      </div>
  );
};
```

## 8. Методы жизненного цикла компонента в React?
* `constructor` это конструктор компонента, который вызывается до того как компонент будет смонтирован.
* `componentDidMount` вызывается сразу послу монтирования компонента, это отличное место для создания сетевых запросов
и настройки подписок компонента на различные события, а так-же в этом методе должны происходить действия, для работы которых
  требуется наличие DOM узлов
* `componentDidUpdate` вызывается сразу после обновления, метод позволяет работать с DOM, при обновлении компонента
* `componentWillUnmount` вызывается перед размонтированием компонента, в нем выполняются необходимые сбросы, отмена таймера,
а так-же сетевых запросов и подписок, созданных в componentDidMount
* `shouldComponentUpdate` вызывается перед рендером, когда получает новые пропсы или состояние, используется для повышения производительности,
чтобы избежать лишних перерисовок
* `render` единственный обязательный метод в компоненте, предназначен для возврата разметки(HTML)
* `getDrivedStateFromProps` вызывается непосредственно перед вызовом метода `render`, возвращает объект для обновления состояния,
или null, чтобы ничего не обновлять, существует для редких случаев, когда состояние зависит от изменен в пропсах.
* `getSnapshotBeforeUpdate` позволяет компоненту, брать некоторую информацию из DOM перед ее возможным изменением.
* `getDrivedStateFromError` вызывается после возникновения ошибки у компонента потомка, он получает ошибку в качестве параметра
и возвращает значение для обновления состояния
* `componentDidCatch` используется для логирования ошибок, вызывается после возникновения ошибки у компонента потомка

## 9. Стадии жизненного цикла компонента в React?
* <font size="5">`mounting(монтирование)`</font> Как известно, компоненты, созданные на основе классов, тоже являются классами. 
  Именно поэтому первый запускаемый метод — `constructor()`. Как правило, именно в `constructor()` мы выполняем 
  инициализацию состояния компонента. 
  
  <br/> Далее компонент запускает `getDerivedStateFromProps()`, потом запускается `render()`, возвращающий JSX. 
  React «монтируется» в DOM. Следующий этап — запуск метода `componentDidMount()`. 
  Тут происходит выполнение всех асинхронных вызовов к базам данных. Итак, компонент «рожден».
  

* <font size="5">`updating(обновление)`</font> Данный этап запускается во время каждого изменения состояния либо свойств. К
  ак и в случае с монтированием, 
  происходит вызов метода `getDerivedStateFromProps()`, однако в этот раз уже без `constructor()`.
  
  <br />Потом происходит запуск `shouldComponentUpdate()`. Тут можно выполнять сравнение старых свойств с новым 
  перечнем свойств либо сравнивать состояния. При этом мы можем указать, надо ли отображать компонент заново, 
  возвращая `true` либо `false` — это даст возможность сделать приложение более эффективным благодаря уменьшению 
  числа лишних отображений. Если же `shouldComponentUpdate()` возвращает false, этап обновлений завершается.

  <br />В обратном случае React отобразится заново, а потом запустится `getSnapshotBeforeUpdate()`. 
  Потом React запустит `componentDidUpdate()`. Как и в случае с `componentDidMount()`, 
  его можно применять для асинхронных вызовов либо управления DOM.
  

* <font size="5">`unmounting(размонтирование)`</font> Все хорошее имеет тенденцию заканчиваться. 
  Когда компонент прожил свою жизнь, наступает размонтирование — последний жизненный этап. 
  Во время удаления компонента из DOM React выполняет запуск `componentWillUnmount()` непосредственно перед удалением. 
  Данный метод применяется при закрытии всех открытых соединений типа web-сокетов либо тайм-аутов.
  
  
## 10. Что такое `React Reconciliation`?
`React Reconciliation` - это механизм сверки, посредством которого React обновляет DOM дерево, когда состояние компонента 
изменяется, React должен рассчитать необходимость обновления DOM, это делается путем создания Virtual DOM и сравнении
его с текущим, в этом контексте Virtual DOM будет содержать новое состояние компонента. 


При сравнении двух деревьев первым делом react сравнивает два корневых элемента, всякий раз когда корневые элементы 
имеют различные типы, react уничтожает старое дерево, и строит новое с нуля.


При сравнении двух react DOM элементов одного типа, react смотрит на атрибуты обоих, сохраняет лежащий в основе этих
элементов DOM узел и изменяет только измененные атрибуты. По умолчанию при рекурсивном обходе дочерних элементов 
DOM узла, react проходит по обоим спискам потомков одновременно, и создает мутацию, когда находит отличие. Когда у дочерних
элементов есть ключи, react использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева


## 11. Что такое `Portal`?
Согласно официальной документации по React, порталы представляют собой первоклассный способ отображения дочерних 
компонентов в узел DOM вне DOM-иерархии родительского компонента, определяемой иерархией дерева компонентов. 
Порталы применяют в ситуациях, когда необходимо, чтобы дочерние компоненты визуально вырывались из родительского контейнера. 
Типичные примеры использования порталов:

* Модальные диалоговые окна.
* Всплывающие подсказки.
* Всплывающие визитки.
* Загрузчики.

Портал создаётся с помощью ReactDOM.createPortal(child, container). Здесь child это элемент, фрагмент или строка React, 
а container это местоположение или узел DOM, в который должен добавляться портал.

Вот пример компонента modal, созданного с использованием приведённого выше API:
```jsx
const Modal =({ message, isOpen, onClose, children })=> {
  if (!isOpen) return null
  return ReactDOM.createPortal(    
    <div className="modal">
      <span className="message">{message}</span>
      <button onClick={onClose}>Close</button>
    </div>,
    domNode)
}
```

Несмотря на то, что портал отображается вне родительского элемента DOM, ведёт он себя аналогично обычному компоненту 
React внутри приложения. Он может получить доступ к props и context API. Почему? 
Потому что портал находится внутри иерархии дерева React.

## 12. Что такое Что такое React хуки `Hooks`?

Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.

## 13. Что такое контекст `Context`?
`Context` - это способ передачи данных через дерево компонентов, без необходимости передавать свойства вручную на каждом уровне 
или простыми словами: для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов

В стандартном react приложении, данные передаются сверху вниз, по иерархии компонентов, или проще говоря, 
от родителя к потомку, через свойство `props`.

```jsx
// (1) File context.js
import React from 'react';
export const ThemeContext = React.createContext('main-theme');

// (2) File App.js
//importing ThemeContext
import { ThemeContext } from './context'

export const App = () => {
  const theme = useContext(ThemeContext);
  
  return <App theme={theme} />
}
```


## 14. Разница между состоянием `state` и пропсами `props`?
`state(состояние)` - это объект содержащий некоторую информацию, которая может измениться с течением жизненного цикла компонентов.
Состояние похоже на props, но оно является приватным и полностью контролируется компонентом, то-есть оно не доступно для 
других компонентов, кроме того, которому оно принадлежит и который его определят.


`props` - это входные данные для компонента, то-есть те которые он получает с наружи, основное назначение props в react,
заключается в предоставлении компоненту следующего функционала:
* Передача данных компоненту
* Вызов изменения состояния
* Использование внутри метода `render()`


`props` и `state` являются обычными javascript объектами, несмотря на то, что они оба содержат информацию, которая используется
при рендеринге компонента, функционал у них разный, `props` передаются компоненту подобно аргументам, передаваемым функции,
а `state` управляется компонентом, как переменная объявленная внутри функции.


## 15. Что такое `React Fiber`?
`React Fiber` - это новый движок согласования, изменение основного алгоритма React 16. Основной задачей `React Fiber`
является повышением производительности в таких областях как: 
* анимация 
* создание макета страницы 
* обработка жестов, 
* возможность приостанавливать, прерывать, или повторно запускать выполнение операций и предоставление приоритета 
определенным типам обновлений

Его основная особенность это так называемый `incremental rendering` - это возможность разделение процесса рендеринга на части,
их объединение через различные фреймы.


## 16. Что такое `Fragment`? Почему `Fragment` лучше, чем `div`?
`Fragment` - это распространенный паттерн react, который используется в компонентах, возвращающих несколько элементов.
`Fragment` позволяет группировать дочерние элементы, без создания дополнительных DOM узлов. Другими словами, это 
специальный тэг JSX, который не отрисовывается внутри реального DOM дерева. `Fragment` немного быстрее, и используют
немного памяти.

```jsx
  // Старый способ написания фрагмента
  return (
    <Fragment>
      <Users />        
    </Fragment>
  )
}
```
```jsx
// Новый способ написания фрагмента
return (
  <>
    <Users />
  </>
)
```


## 17. Что такое синтетические события в React?
Ваши обработчики событий получают экземпляр SyntheticEvent, это кроссбраузерная обёртка над нативным экземпляром события.
У неё такой же интерфейс, как и у нативного события, включая методы stopPropagation() и preventDefault(). Эта обёртка
помогает событиям работать одинаково во всех браузерах.

Если вам всё-таки нужно получить нативное браузерное событие, обратитесь к атрибуту nativeEvent. Синтетические события 
отличаются от нативных событий браузера и непосредственно не связаны с ними. Например, в синтетическом событии 
onMouseLeave атрибут event.nativeEvent будет указывать на mouseout. Эта деталь реализации не является частью публичного 
API, поэтому может измениться со временем.