### Разница между синхронными и асинхронными функциями?
* Синхронные функции являются блокирующими, в то время как асинхронные, нет.
Другими словами, во время выполнения JavaScript, когда интерпретатор натыкается
на синхронную функцию, он блокирует дальнейшее выполнение операций, прежде чем данная
функция будет выполнена, поэтому набор таких функций выполняется последовательно
одна за другой.

* Асинхронные функции не блокируют дальнейшее выполнение скрипта, именно поэтому различные
тяжелые операции, по типу запроса данных делают асинхронными, обычно такие функции параметром
принимают коллбэк, это еще одна функция, которая будет вызвана, как только выполниться асинхронная операция
и которая сможет обработать полученный результат



### Что такое `AJAX (Async JavaScript And XML)`?
`AJAX` это не технология, а термин который описывает подход использования несколько существующих технологий вместе, 
для работы на стороне клиента и для создания асинхронных веб приложений, 
с помощью `AJAX`, веб приложения могут отправлять данные на сервер и получать их с сервера асинхронно,
таким образом происходит отделение логики представления(отрисовка UI) от логики обмена данными, 
в результате страницы могут динамически изменять содержимое без полной перезагрузки, 
поэтому они работают быстрее и становятся более отзывчивыми к действиям пользователей.


### Что такое `same-origin-policy` в контексте JavaScript?
`same-origin-policy` или принцип одинакового источника, определяет, как документ или скрипт
загруженный из одного источника может взаимодействовать с ресурсом из другого источника.
Другими словами этот принцип не позволяет javascript выполнять запросы за границы домена



### Что такое `event loop`? 
Во-первых, javascript является однопоточным языком, то-есть в текущий момент времени может выполнятся одна задача, 
и если эта задача ресурсоёмкая, то мы не сможем приступить к следующей, пока не выполнится предыдущая. 
То-есть появляется вопрос: как в однопоточном javascript выполнять асинхронный код? 
И в этом нам помогает такая концепция как `event loop`.


### Что такое `Promises`?
`Promises` это один из приемов работы с асинхронным кодом, это объект который может вернуть одно значение в будущем.
Это либо выполнено, либо причина по которой промис не выполнился, то-есть ошибка.
Promise может находиться в одном из трех возможных состояний: `Выполнено(Fulfiled)`, `Отклонено(Rejected)`, `Ожидание (Pending)`.


### Плюсы и минусы использования AJAX?
Плюсы:
* Повышение интерактивности
* Сокращение кол-ва обращений к серверу
* Хранение состояния страницы


Минусы:
* Сложность реализации закладки страницы.
* Не работает без JavaScript.
* Динамический контент не виден роботам.


### Подходы при работе с асинхронным кодом?
* `Коллбэки`. Внутри одной синхронной функции записывается другая и т.д, до тех пор, пока не получается многоуровневая вложенность.
* Использование `Promise`. В этом случае асинхронная функция возвращает специальный объект, который называется Promise.
Используя его, а так-же специальные методы then и catch, можно обрабатывать получаемые данные и передавать их дальше по цепочке
* `async await` для общей функции добавляется ключевое слово async, а внутри каждая асинхронная операция помечается как await, таким образом исполнение асинхронного кода идет наподобие синхронного
=======
* Коллбэки. Внутри одной синхронной функции записывается другая и т.д, до тех пор, пока не получается многоуровневая вложенность.
* Использование Promise. В этом случае асинхронная функция возвращает специальный объект, который называется Promise.
* Используя его, а так-же специальные методы then и catch, можно обрабатывать получаемые данные и передавать их дальше по цепочке
* async await. Для общей функции добавляется ключевое слово async, а внутри каждая асинхронная операция помечается как await, таким образом исполнение асинхронного кода идет на подобие синхронного


### Что такое коллбэк-функция `Callback`? Что такое `Callback Hell`?
В JavaScript функции — это объекты. Поэтому функции могут принимать другие функции в качестве аргументов, 
а также функции могут возвращать функции в качестве результата. Функции, которые это умеют, называются функциями высшего порядка. 
А любая функция, которая передается как аргумент, называется `callback-функцией`


`Callback Hell` это такая вложенность коллбэков, при которой получается несколько уровней, то-есть первая функция возвращает вторую,
вторая третью и т.д. В итоге получается плохо читаемый код, который трудно поддерживается.


### Что такое `async/await`?
`async/await` это новый способ написания асинхронного кода в JavaScript, он построен на основе промисов и это делает написание
асинхронного кода более читаемым и чистым.

`async/await` заставляет код который работает асинхронно, выглядеть как синхронный код.

Ключевое слово `async` перед объявлением функции, заставляет функцию неявно возвращать промис.

Ключевое слово `await` можно использовать только внутри асинхронной функции. Ключевое слово `await` ожидает возврата выражения из правой части,
перед выполнением следующей строки кода.


### Что такое `Promise.all()`?
Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.
Например, параллельно загрузить несколько файлов и обработать результат, когда он готов.
Для этого как раз и пригодится `Promise.all`.


Метод Promise.all принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив)и возвращает новый промис.
Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.
Например, Promise.all, представленный ниже, выполнится спустя 3 секунды, его результатом будет массив [1, 2, 3]:
```js
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// каждый промис даёт элемент массива
```


### ### Что такое `Promise.race()`?
Метод очень похож на Promise.all, но ждёт только первый выполненный промис, из которого берёт результат (или ошибку).
```js
Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```

### Что такое `Promise.allSettled()`?
Promise.allSettled() также как и Promise.all() принимает набор промисов и выполняет их как единое целое, 
но возвращает объект со статусом и результатом промиса:
```js
const promise1 = new Promise((resolve,reject) => {
    reject("Непредвиденная ошибка");
    setTimeout(resolve, 500, "Hello");
});
const promise2 = new Promise((resolve,reject) => {
    setTimeout(resolve, 1000, "World");
});
  
Promise.allSettled([promise1, promise2])
    .then(values => {
        const [promise1data, promise2data] = values;
        console.log(promise1data);  // {status: "rejected", reason: "Непредвиденная ошибка"}
        console.log(promise2data);  // {status: "fulfilled", value: "World"}
});
```


### ### Что такое `Promise.any()`?
Функция `Promise.any()` принимает несколько промисов и возвращает первый успешно завершившийся промис:
```js
const promise1 = new Promise((resolve, reject) => {
  reject("error in promise1");
  setTimeout(resolve, 500, "Hello");
});
const promise2 = new Promise((resolve) => {
  setTimeout(resolve, 1000, "World");
});
Promise.any([promise1, promise2])
  .then(value => console.log(value)) // World
  .catch(error => console.log(error));
```