### Типы данных в JavaScript?
В JavaScript существует 8 типов данных.
```js
typeof 'str' // string - строковый тип данных
typeof 2 // number - числовой тип данных
typeof 1n // BigInt 
// В JavaScript тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991)
// Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.
typeof true || false // boolean - булевый тип данных
typeof Symbol() // Тип symbol (символ) используется для создания уникальных идентификаторов в объектах
typeof null // null - специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
typeof undefined // undefined - неопределенное значение.
typeof {} // object - объект
```
`Оператор typeof возвращает тип аргумента.`


###  В чем разница между операторами `==` и `===`?

Разница между оператором `==` (абстрактное или нестрогое равенство) и оператором `===` (строгое равенство) 
состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу (Coersion), 
а второй — без такого преобразования.
````js
console.log(1 == "1"); // true
console.log(1 === "1"); // false
````

### Что такое Strict mode в JavaScript?
Strict mode позволяет использовать более строгий вариант JavaScript синтаксиса

Плюсы:
- Не позволяет случайно создавать глобальные переменные.
- Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.
- При попытке удалить неудаляемые свойства, выдаст исключение.
- Требует, чтобы имена параметров функции были уникальными.
- this в глобальной области видимости равно undefined.
- Перехватывает распространенные ошибки, выдавая исключения.
- Исключает неочевидные особенности языка.
  
Минусы:
- Нельзя использовать некоторые особенности языка.
- Нет доступа к function.caller и function.arguments.
- Объединение скриптов, в строгом режиме может вызвать проблемы.

```js
// Глобально
"use strict"

// Внутри функции
function fun() {
    "use strict"
};
```

### Разница между Function Declaration и Function Expression?
```js
funDeclaration(2, 2) // 4
funExpression(3, 3) // Error

// Function Declaration
function funDeclaration(a, b) {
    return a + b;
};

// Function Expression
var funExpression = function(a, b) {
    return a * b;
};
```

### Разница между `null` и `undefined`?
`null` — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно.


`undefined` («неопределенный») представляет собой значение по умолчанию:
- переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;
- функции, которая ничего не возвращает явно, например, console.log(1);
- несуществующего свойства объекта.


### Операторы «И» и «ИЛИ» `&&` и `||`?

Оператор `&&` (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные.

Оператор `||` (логическое или) находит и возвращает первое истинное значение либо последний операнд, когда все значения ложные.


### Типы таймеров в JavaScript?
```js
const sayHi = () => console.log('hello')

setTimeout(sayHi, 1000); // Вернет функцию sayHi() через секунду

setInterval(sayHi, 1000); // Будет вызывать sayHi() через каждую секунду
```


### Что такое `Hoisting (поднятие)`?
`Hoisting` это механизм подъема функции или переменной в глобальную, или функциональную область видимости.
JavaScript сначала объявляет, а уже затем инициализирует наши переменные.
Переменным объявленным через `var`, а также функциям объявленным как function declaration, можно получить доступ еще до
объявления значения.


### Что такое область видимости `Scope`?
Область видимости или scope это место, откуда мы имеем доступ к переменным или функциям.
В JavaScript есть 3 областей видимости:
- Глобальная (функции или переменные объявленные в данной области становятся глобальными, появляются в глобальном пространстве имен
и доступны из любого места в коде)
- Функциональная или локальная (переменные и функции объявленные внутри функции, доступны только этой функции и всем вложенным в нее функциям)
- Блочная (переменные объявленные через `let` и `const`, которые находятся внутри фигурных скобок `{}`, могут использоваться только внутри этих скобок)

Область видимости - это по сути набор правил, по которым происходит поиск переменных. Сначала переменная ищется в локальной области,
если ее нет, поиск происходит во внешней области и так далее пока не дойдет до глобальной.


### Разница между `var`, `const` и `let`?
Переменные объявленные через `var` всплывают, то-есть если мы захотим обратиться к ней до ее инициализации, то мы получим `undefined`.
В случае с `let` и `const` мы увидим ошибку.

У `let` и `const` область видимости ограниченна блоком, `var` такую область видимости игнорирует.

Переменная объявленная через `const` становится константой и ее невозможно переопределить, попытка вызовет ошибку.


### Что такое замыкание `Closure`?

При создании функции и использовании внутри нее переменных, эти переменные доступны только локально внутри функции, 
снаружи мы не можем получить к ним доступ, на хранение таких переменных, в том числе и аргументов, выделяется определенная память 
и когда функция заканчивает свое выполнение эта память очищается, таким образом эти переменные больше нигде не существуют.


Но если внутри одной функции, создать вторую, то вложенная функция получит доступ к переменным которые были объявлены во внешней функции, 
этот механизм и называется замыканием, то-есть вложенная функция замыкает на себе переменные и аргументы внешней функции. 
При отработке внешней функции возвращается внутренняя, которая замыкается на значении внешней и не дает памяти очиститься.


### Что означает `this` в JavaScript?
Это контекст вызова, или ссылка на значение объекта, который в данный момент выполняет, или вызывает функцию.


### Что такое функции высшего порядка `Higher Order Function`?
Функции высшего порядка это функции, которые принимают другие функции или же принимают другую функцию в качестве аргумента.
Например `map`, `filter`, `forEach` и т.д.


### Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?
Для того, чтобы преобразовать любой тип данных в булевое значение, то-есть `true` либо `false`, можно использовать
один из двух подходов:
```js
// Функция Boolean();
Boolean(null); // false
Boolean(0); // false
Boolean(1); // true
Boolean('str') // true

// !! - двойное отрицание
!!{}; // true
!!'str'; // true
!!''; // false
!!undefined; // false
```
В JavaScript есть 6 основных элементов, которые возвращают ложное значение.
```js
'', 0, null, undefined, NaN, false
```


### Часто используемые методы строк в JavaScript?
```js
let str = 'Hello World';

str.length; // 11.  Позволяет узнать длину строки, возвращает числовое значение
str.charAt(1); // "e".  Метод charAt() возвращает позицию указанного символа из строки.
str.toUpperCase(); // "HELLO WORLD".  Переводит символы в верхний регистр.
str.toLowerCase(); // "hello world".  Переводит символы в нижрний регистр.
str.indexOf('l'); // 2. Используется для поиска указанного текста в строке. Если не найден, то вернет -1.
str.lastIndexOf('l'); // 9. Если в строке одинаковый текст или символ, то вернет позицию последнего найденного символа.
str.slice(0, 3); // "Hel". Метод slice() возвращает новый массив, содержащий копию части исходного массива.
str.substring(0, 5); // "Hello".  Метод substring() возвращает подстроку строки между двумя индексами, или от одного индекса и до конца строки.
str.split(''); // [H, e, l, l, o, " ", W, o, r, l, d].  Превращает строку в массив
str.split(' '); // [Hello, World]
str.replace("World", "JavaScript"); // "Hello JavaScript".  Заменет значение в строке
'  hello     '.trim(); // "hello".  trim() позволяет убрать пробелы в начале и в конце строки 
```


### Что такое чистая функция?
Чистая функция должна удоволетворять двум условиям:
- В ней не должно быть побочных эффектов.(Видоизменение входных параметров, http запросы, DOM запросы, изменение файловой системы)
- Каждый раз она возвращает одинаковый результат, когда вызывается с тем-же набором аргументов
```js
// Чистая функция
const add = (x, y) => x + y; // Принимает два аргумента и с ними же оперирует.
add(4, 4); // 8

// Нечистая функция
let x = 4; // Зависит от внешней переменной
const add = (y) => {
  x += y
};
add(4); // 8
```