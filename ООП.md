## Процедурное программирование(или функциональное).
Приложение написанное в процедурном подходе проходит три этапа:
* Получение аргументов для работы.
* Выполнение функции(или процедур).
* Возвращение результата.

```js
const isPalindrom = (str) => {
	return str === str.split('').reverse().join('');
	
	// Result:
	isPalindrom('тест'); // false
	isPalindrom('шалаш'); // true
}
```
Изначально код писался в таком стиле. И по истечению времени всплыло несколько серьезных проблем:
* Большое количество кода
* Трудность в чтении и анализе логики
* Сложность в организации отдельных модулей и структур
* Сложность для композиции или разделении логики
В результате появилось `объектно-ориентированное программирование(ООП)`


## `Объектно-ориентированное программирование(ООП)`
Его основная идея в том, что любую структуру в приложении, можно представить в виде объекта или класса
со своими свойствами и методами, эти свойства и методы можно расширять, наследовать, изменять передавать и т.д


### Первая концепция это `объект`

`Объект` это элементарная единица в ООП, которая представляет из себя набор свойств, и каждое свойство
состоит из имени и значения, ассоциированного с этим именем.
Например:

```js
// Внутри круглых скобок, с помощью пары, ключ-значение, этот объект можно описать
const bmwAuto = {
  name: 'BMW', // Определяем марку автомобиля
  model: 'X6', // Определеям модель
  year: 2021, // Год выпуска
  // Все 3 описанных значения, называются свойствами объекта, так как внурь них присваиваются примитивные данные
  getAutoType() {
  	return `${this.name} ${this.model} - ${this.year}`
  }
  // Если одно из свйоств производит какие-то операции, тоесть по сути является функциец, то данное значени называется методом
  // Метод это действие, которое может осуществлять объект 
}
```
И хоть объект, довольно удобная структурная единица, однако он не такой гибкий как хотелось бы,
поэтому дополнительной надстройкой над объектом можно назвать класс


### `Класс`
В ООП класс это расширяемый шаблон кода, для создания объектов, который устанавливает в них начальное значение
и реализацию поведения.
```js
// Для создания класса используется ключевое слово class
/* Класс может содерджать constructor, это особый метод который вызывается во время инициализации класса 
и создает свойство, тоесть подготавливает объект для дальнейшего использования.
В классе может быть только один конструктор
 */
class Auto {
  constructor(name, model, year) { // Передаем внутрь конструктора 3 параметра
  	// Присваиваем эти значения объекту, который будет создан на основании класса, после чего они станут свойствами
  	// this нужен для оперделения контекста
    this.name = name;     
    this.model = model;
    this.year = year;
  }
  
  // Как и в объектах внутри класса можно определеить функцию, которая как мы знаем будет называться методом
  getAutoType() {
    return `${this.name} ${this.model} - ${this.year}`
  }
  /* Вы можете заметить, что объект и класс очень похожи, но класс это более широкое понятие
    с дополнительными возможностями
   */
}
```

## Возможности классов.
* Экземпляр класса(инстанс). Если объект создается на основании класса, то он называется экземпляром класса или инстанс

```js
// Для того, чтобы создать объект, класс используется с ключевым словом new
class Auto {
  constructor(name, model, year) { 
    this.name = name;
    this.model = model;
    this.year = year;
  }

  getAutoType() {
    return `${this.name} ${this.model} - ${this.year}`
  }

}

// Instance creation
const bmwAuto = new Auto('BMW', 'X6', 2021);
const mersedesAuto = new Auto('Mersedes', 'e200', 2020);
const audiAuto = new Auto('Audi', 'Q8', 2019);
// На основании одного класса, можно создать сколько угодно экземпляров
```


# `ООП`
Всё объектно-ориентированное программирование базируется на 3 основных концепциях:
* `Наследование`
* `Инкапсуляция`
* `Полиморфизм`

## `Наследование`
`Наследование` это создание новых классов, на основе существующих. То есть на основании одного класса можно создать
еще один, в котором существующие свойства и методы будут унаследованы, но по желанию их можно переопределить
```js
class Auto {
  constructor(name, model, year) { 
    this.name = name;
    this.model = model;
    this.year = year;
  }

  getAutoType() {
    return `${this.name} ${this.model} - ${this.year}`
  }

}

class MersedesCar extends Auto { // Ключевое слово extends позволить нам наследоваться от родительского класса
	
}

const mersedesAuto = new MersedesCar('Mersedes', 'e200', 2020)
mersedesAuto.getAutoType() // Mersedes e200 - 2020
// Мы ничего не определяли внутри этого класса, свойства и методы полностью наследуются от родителя

// Если нам требуется переопределить свойства, нужно использовать метод constructor добавляя ключевое слово super
class MersedesCar extends Auto {
  constructor(name, model, year) {
    super(name, model, year) // Данное слово, запустит механизм наследования конструкторов
    // Сначала будет запущен конструктор родителя, а затем дочерний
      
    // Далее определяем свойство будущего объекта
    this.name = name;
    this.model = `${model} Model`
    this.year = year
  }
		
  getCarModel() {
    return this.model;
  }
}

// Instance creation
const mersedesAuto = new MersedesCar('Mersedes', '300', 2021);

mersedesAuto.getCarModel(); // '3 Model'
mersedesAuto.getAutoType(); // 'Mersedes e200 - 2020'
```

## `Инкапсуляция`
`Инкапсуляция` представляет сокрытие состояния объекта от прямо доступа из вне

```js
class Auto {
  constructor(name, model, year) { 
    this.name = name;
    this.model = model;
    this.year = year;
  }
}

const bmwAuto = new Auto('BMW', 'X5', 2020)

// К каждому из этих свойтв мы можем обратиться и получить значение, или поменять
bmwAuto.name; // BMW
bmwAuto.model; // X5
bmwAuto.year; // 2020

// Мы можем обратиться на прямую через класс
Auto.name; // BMW
Auto.model; // X5
Auto.year; // 2020
```
Это является проблемой, так как публичные данные могут быть намеренно или ошибочно изменены, что в итоге приведет к 
неправильному выполнению программы.


Концепция инкапсуляции прекрасно решает эту проблему

```ts
class Auto {
  public name: string;
  public model: string;
  public year: number;
  private vin: number

  constructor(name: string, model: string, year: number) {
    this.name = name;
    this.model = model;
    this.year = year;
    this.vin = (new Date().getTime())
  }
}

const audiAuto = new Auto('Audi', 'Q8', 2020)

// Как мы видем мы не можем обратиться к приватному свойству vin, доступно оно только в классе Auto
audiAuto.name; // Audi
audiAuto.model; // Q8
audiAuto.vin; // Property 'vin' is private 
```
Если все же нужно получить доступ к приватному значению снаружи, то можно воспользоваться get

```ts
class Auto {
  public name: string;
  public model: string;
  public year: number;
  private vin: number

  constructor(name: string, model: string, year: number) {
    this.name = name;
    this.model = model;
    this.year = year;
    this.vin = (new Date().getTime())
  }
		
  get vinNumber() {
    return this.vin
  }
}
```
Таким образом мы можем защитить наш класс от неконтролируемых изменений, а доступ к свойствам реализовать с помощью
дополнительных методов.

## `Полиморфизм`
`Полиморфизм(poly(много) + morphism(изменение формы или поведения))` в ООП он используется когда нужно чтобы интерфейс
функции был достаточно гибким, чтобы принимать разные типы, или количество параметров, кроме того, чтобы на основании 
типов параметров логика функции могла изменяться. Другими словами полиморфизм означает способность вызывать один и тот же
метод для разных объектов и каждый объект на это действие будет реагировать по разному

```ts
class Auto {
  constructor(name, model, year) { 
    this.name = name;
    this.model = model;
    this.year = year;
  }

  getAutoType() {
    return `${this.name} ${this.model} - ${this.year}`
  }

}

// Предположим, что на основании этого родительского класса нужно создать 3 класса наследника
// В каждом классе будет собственная реализация getAutoType()
class BmwCar extends Auto {
  getAutoType() {
    return `${this.name}, ${this.model}, ${this.year}`
  }		
}

class AudiCar extends Auto {
  getAutoType() {
    return `${this.name} - ${this.model} - ${this.year}`
  }
}

class MersedesCar extends Auto {
  getAutoType(): string {
    return `${this.name} / ${this.model} / ${this.year}`
  }
}

// Далее на основании классов создаем 3 экземпляра
const bmwAuto = new BmwCar('BMW', 'X6', 2021);
const audiAuto = new AudiCar('Audi', 'Q7', 2020);
const mersedesAuto = new MersedesCar('Mersedes', 'e200', 2020)

const autos = [bmwAuto, audiAuto, mersedesAuto];

const getAutoTypes = (autos) => 
  autos.map(auto => auto.getAutoType());

console.log(getAutoTypes(autos)) // ["BMW, X6, 2021", "Audi - Q7 - 2020", "Mersedes / e200 / 2020"]
```
За счет того, что методы во всех 3 классах имеют одинаковое имя, даже если логика реализации различна
мы можем вызвать его и получить адекватный результат. Отсюда и название polymorphism(одинаковая работа с разными формами)


## `Интерфейс`
`Интерфейс` определяет свойства или методы, которые объект или класс должны реализовать, однако внутри себя
интерфейс не содержит никаких реализаций.

Очень хороший пример для понимания `интерфейсов` это оглавление книги, оно помогает понять структуру книги, 
порядок глав, страница с который главы начинаются, но само по себе оглавление не содежит никакого полезного описания.

```ts
interface AutoFactory {
    // readonly указывает нам что два первых значения только для чтения и попытка их изменения вызовет ошибку
    readonly name: string;
    readonly model: string;
    year: number;

    getAutoType(): string
}

// Интерфейфс не может создавать экземпляры, но на основании интерфейса можно создать класс
class Auto implements AutoFactory {
    public name: string;
    public model: string;
    public year: number;

    constructor(name: string, model: string, year: number) {
      this.name = name;
      this.model = model;
      this.year = year
    }
    
    getAutoType() {
        return `${this.name} ${this.model} / ${this.year}`
    }
}
```
Еще одна отличительная особенность наследования от интерфейса, это то, что в классе наследнике должны быть реализованы
все свйоства и методы, которые описаны в интерфейсе.


## `Абстракция`
Она чем то похоже на интерфейс, но со своими особенностями

Абстракция - это способ создания простой модели, которая содержит только важные свойства с точки зрения контекста 
приложения, из более сложной модели. Иными словами - это способ скрыть детали реализации и показать пользователям 
только функциональность. Абстракция игнорирует нерелевантные детали и показывает только необходимые. Важно помнить, 
что мы не можем создать экземпляр абстрактного класса.

Всё программное обеспечение - это абстракция, скрывающая всю тяжелую работу и бездумные детали.

Многие программные процессы повторяются снова и снова. Поэтому, на этапе декомпозиции проблемы, мы удалим дублирование, 
записывая какой-либо компонент (функцию, модуль, класс и т. Д.), присваивая ему имя (идентификатор) и повторно используя 
его столько раз, сколько нам нужно.

Процесс декомпозиции - это процесс абстракции. Успешная абстракция подразумевает, что результатом является набор
независимо полезных и перекомпонованных компонентов.
```ts
abstract class AutoFactory {
  readonly name: string;
  readonly model: string;
  year: number;
  
  abstract getAutoType(): string;
}
```